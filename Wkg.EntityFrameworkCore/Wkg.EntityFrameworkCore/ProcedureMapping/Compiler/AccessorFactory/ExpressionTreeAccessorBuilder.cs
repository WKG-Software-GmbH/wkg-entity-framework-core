using System.Linq.Expressions;
using System.Reflection;
using Wkg.EntityFrameworkCore.ProcedureMapping.Compiler.Output;
using Wkg.Reflection;

namespace Wkg.EntityFrameworkCore.ProcedureMapping.Compiler.AccessorFactory;

/// <summary>
/// An <see cref="IAccessorBuilder"/> that uses expression trees to create parameter accessors.
/// </summary>
[Obsolete("Use ILAccessorBuilder instead! ILAccessorBuilder is way faster", true)]
internal readonly struct ExpressionTreeAccessorBuilder : IAccessorBuilder, IAccessorBuilderFactory
{
    /// <summary>
    /// The argument types for the field setter delegate <see cref="FieldInfo.SetValue(object?, object?)"/>, cached for performance (read-only, so thread safe)
    /// </summary>
    private static readonly Type[] _fieldSetValueParameterTypes = new Type[] { typeof(object), typeof(object) };

    /// <summary>
    /// The property info of the property this accessor builder is for
    /// </summary>
    private readonly PropertyInfo _pInfo;

    /// <summary>
    /// The type of the owner of the property (the type that contains the property)
    /// </summary>
    private readonly Type _ownerType;

    /// <summary>
    /// The throw helper used to throw exceptions
    /// </summary>
    private readonly IThrowHelper _throwHelper;

    /// <summary>
    /// Creates a new <see cref="ExpressionTreeAccessorBuilder"/> with the specified property info and throw helper.
    /// </summary>
    /// <param name="propertyInfo">The property info of the property this accessor builder is for.</param>
    /// <param name="throwHelper">The throw helper used to throw exceptions.</param>
    private ExpressionTreeAccessorBuilder(PropertyInfo propertyInfo, IThrowHelper throwHelper)
    {
        _pInfo = propertyInfo;
        _throwHelper = throwHelper;
        _ownerType = _pInfo.DeclaringType!;
    }

    [Obsolete("Use factory method instead!", true)]
    public ExpressionTreeAccessorBuilder()
    {
        throw new InvalidOperationException("Use factory method instead!");
    }

    /// <inheritdoc/>
    public PropertyGetter BuildGetter()
    {
        // create a parameter expression for the context
        ParameterExpression context = Expression.Parameter(typeof(object), nameof(context));
        // create the expression tree for the getter
        // this is equivalent to:
        // (object owner) => (object)(((OwnerType)owner).Property);
        Expression<PropertyGetter> getterExpression = Expression.Lambda<PropertyGetter>(
            // convert the property value to object
            Expression.Convert(
                // get the property value
                Expression.Property(
                    // convert the owner to the owner type
                    Expression.Convert(context, _ownerType),
                    // get the property info of Property
                    _pInfo),
                typeof(object)),
            context);

        // compile the expression tree into IL and return the delegate
        return getterExpression.Compile();
    }

    /// <inheritdoc/>
    public PropertySetter BuildSetter()
    {
        // create a parameter expression for the context
        ParameterExpression contextParam = Expression.Parameter(typeof(object), nameof(contextParam));

        // get the backing field for the property
        // this is the field that is automatically generated by the compiler when you use the auto property syntax (int Foo { get; set; })
        // if the property does not have an auto-generated backing field we throw an exception (we do not support manually implemented properties)
        FieldInfo backingField = _pInfo.GetBackingField()
            // throw an InvalidOperationException if there is no backing field
            ?? _throwHelper.Throw<InvalidOperationException, FieldInfo>($"Parameter is an output parameter, but linked property {_pInfo.Name} does not have a valid auto-generated backing field.");
        // get the setter for the backing field
        MethodInfo backingFieldSetter = typeof(FieldInfo)
            .GetMethod(
                nameof(FieldInfo.SetValue),
                BindingFlags.Instance | BindingFlags.Public,
                _fieldSetValueParameterTypes)!;

        // create a parameter expression for the value
        ParameterExpression valueParam = Expression.Parameter(typeof(object), nameof(valueParam));

        // create the expression tree for the setter
        // this is equivalent to:
        // (object owner, object value) => backingField.SetValue(owner, value);
        // we cannot directly assign the value to the backing field as we did in IL, because .NETs reflection code is smart and determines the field
        // to be readonly (for get or init properties) and then just dies :P
        // so we have to do some inception-level reflection craziness and reflectively call the reflected backing field's setter, because that for some reason works...
        Expression<PropertySetter> setterExp = Expression.Lambda<PropertySetter>(
            Expression.Call(
                // get the backing field as a constant
                Expression.Constant(backingField),
                // get the backing field setter
                backingFieldSetter,
                // get the context parameter
                contextParam,
                // get the value parameter
                valueParam),
            // set the parameter names
            contextParam,
            valueParam);

        // compile the expression tree into a delegate
        return setterExp.Compile();
    }

    /// <inheritdoc/>
    public static IAccessorBuilder CreateBuilder(PropertyInfo propertyInfo, IThrowHelper throwHelper) => new ExpressionTreeAccessorBuilder(propertyInfo, throwHelper);

    public PropertySetter<T> BuildSetterDirect<T>() => throw new NotSupportedException();
}